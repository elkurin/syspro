(イ) 
実装の仕方によってだいぶ結果が変わる
2種類の実装を行った

btree.cではglobal変数nextをfunの中で計算してtreeに挿入する
この方法ではnextの中身を計算する時にも同時アクセスが発生するためものすごく衝突しやすそう
結果output_btree.txtをみる通り、半分以上が消えている

btree1.cでは渡す&arg自体がnextの役割を果たしており、btree.cに比べるとかなり挿入が成功している
output_btree1.txtをみると、500/10000 くらい消えている

(ロ)
lock_btree.cに実装
ちゃんとロックしたらちゃんと答えが出た
また、argに挿入する値を渡していたところ、これはポインタなのでこの中身が書き換わってしまっておなじ値を挿入することがたまに発生し、ロックしても一部のノードが消えてしまっていた
結果はoutput_lockの通り


時間を計測すると明らかにロの方が遅い
10回計測した平均は以下
btree 	0.081680
lock 	0.340584
これは、ロではちゃんと同時アクセスが封じられているということである
