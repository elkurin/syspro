make cp で純粋なシステムコールを使ったcpコマンド
make fcp で高水準関数を使ったcpコマンド
をコンパイルできる

いずれも
"実行ファイル" "copy元のファイル" "copy先のファイル"
と打つことでコピーできる

6000KB程度のhoge.txtを用意してそれをdummy.txtにコピーすることで計測した

計測時間は10回ずつの平均を計算した
cp.cを実行した結果
純粋なシステムコールのみを使用した場合
8192バイトずつ	-> 0.003124
1バイトずつ		-> 3.900121

fcp.cを実行した結果
fopenなどの関数を使った場合
8192バイトずつ 	-> 0.023178
1バイトずつ 	-> 0.280128


以上より、普通に使うときは純粋ななシステムコールの方が速い操作が出来るが、freadやfwriteを使った方が細かい単位で操作を行ったときそこまで遅くならないという結果になった

この原因をstraceで確認する
以下のコマンドを使用
$ strace -c ./a.out

cp.c
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 57.66    0.024931           0   6888891           write
 42.34    0.018307           0   6888892           read
  0.00    0.000000           0         4           open
  0.00    0.000000           0         4           close
  0.00    0.000000           0         3           fstat
  0.00    0.000000           0         8           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         1           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.043238              13777813         3 total

fcp.c
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0      1684           read
  0.00    0.000000           0      1683           write
  0.00    0.000000           0         4           open
  0.00    0.000000           0         4           close
  0.00    0.000000           0         5           fstat
  0.00    0.000000           0        10           mmap
  0.00    0.000000           0         4           mprotect
  0.00    0.000000           0         3           munmap
  0.00    0.000000           0         3           brk
  0.00    0.000000           0         3         3 access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.000000                  3405         3 total

明らかに高水準ライブラリだと試行回数が少ない
高水準ライブラリでは、読み込むsizeにかかわらず、ある程度を一度に読み込んですぐアクセス可能なところに格納し、その後に指定されたsizeごとに分割して返していると考察する

-----再提出の修正箇所-----
課題Bと同じ訂正を行なった
